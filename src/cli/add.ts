import { formatTree } from "tutils/ansi"
import { capitalize } from "tutils/misc"
import { containsPath, getDir, getName, joinPath, normalizePath, relativePath, resolvePath } from "tutils/path"
import { exec } from "tutils/process"
import { Builder } from "../builder"
import { readConfigs } from "../configs"
import { formatMarkdownList, MarkdownListItem } from "../shared/markdownList"
import { findContainer } from "./index"

export default async function (options: any) {
	const url = options[1]
	if (!url) {
		console.info(`用法: tdk add <模块路径> [模块名]`)
		console.info(`  如: tdk add ui/textBox 文本框`)
		return 0
	}
	const list = await add(url, {
		name: options["--name"],
		displayName: options[2],
		description: options[3],
		author: options["--author"] ?? exec("git config user.name").result.stdout,
		email: options["--email"] ?? exec("git config user.email").result.stdout,
		version: options["--version"],
		date: options["--date"],
		tpl: options["--tpl"]
	}, !options["--no-update-index"], options["--root"])
	if (!list) {
		console.error(`模块已存在: ${url}`)
		return 1
	}
	if (!list.length) {
		console.error(`模块文件夹为空或不存在: ${url}`)
		return 2
	}
	console.info(`模块创建成功: ${url}`)
	console.info(formatTree(listToTree(list)))
	return list.length
}

export const description = "创建一个模块"
export const argument = "模块名"

/**
 * 创建一个模块，返回新建的文件列表，如果目标模块已存在则返回空
 * @param url 要新建的模块地址
 * @param options 附加选项
 * @param updateIndex 是否添加到索引
 * @param root 根文件夹
 */
export async function add(url: string, options: AddOptions = {}, updateIndex = true, root?: string) {
	url = normalizePath(url)
	const builder = new Builder(readConfigs())
	root ??= builder.options.srcDir
	const dir = resolvePath(root, url)
	if (await builder.fs.existsDir(dir)) {
		return null
	}
	const name = options.name ?? getName(url)
	const data = {
		path: url,
		dir: getDir(url),
		name,
		nameLower: name.toLowerCase(),
		namePascal: capitalize(name),
		displayName: options.displayName ?? name,
		description: options.description ?? "",
		author: options.author ?? "",
		email: options.email ?? "",
		version: options.version ?? "0.0.1",
		date: options.date ?? new Date().toLocaleDateString(),
	}
	let tpl = options.tpl
	if (tpl == undefined || !/[\\\/]/.test(tpl)) {
		tpl = await findTPLDir(getDir(dir), tpl ?? ".tpl") ?? __dirname + "/../../tpl"
	}
	const list: string[] = []
	await builder.fs.walk(tpl, {
		async file(path) {
			const targetPath = `${dir}/${relativePath(tpl, path).replace("tpl", name)}`
			if (await builder.fs.writeFile(targetPath, renderTPL(await builder.fs.readText(path), data), false)) {
				list.push(targetPath)
			}
		}
	})
	if (updateIndex) {
		const index = await builder.docCompiler.loadPageIndex(root)
		if (!index.autoGenerated) {
			findContainer(index.items, url).push({
				title: data.displayName,
				subtitle: data.namePascal,
				url: url
			} as MarkdownListItem)
			await builder.fs.writeFile(index.path, index.header + formatMarkdownList(index.items) + index.body)
			list.push(index.path)
		}
	}
	return list

	async function findTPLDir(dir: string, tplDirName: string) {
		const path = joinPath(dir, tplDirName)
		if (await builder.fs.existsDir(path)) {
			return path
		}
		const parent = getDir(dir)
		if (!containsPath(builder.options.baseDir, parent, builder.fs.isCaseInsensitive)) {
			return null
		}
		return findTPLDir(parent, tplDirName)
	}

}

/** 添加参数 */
export interface AddOptions {
	[key: string]: string
	/** 使用的模板 */
	tpl?: string
	/** 模块名 */
	name?: string
	/** 显示名 */
	displayName?: string
	/** 描述 */
	description?: string
	/** 作者 */
	author?: string
	/** 作者邮箱 */
	email?: string
	/** 当前日期 */
	date?: string
	/** 版本号 */
	version?: string
}

/**
 * 渲染一个模板
 * @param tpl 模板内容
 * @param data 模板数据
 */
function renderTPL(tpl: string, data: any) {
	return tpl.replace(/__(\w+)__/g, (all, field) => data[field] ?? all)
}

function listToTree(list: string[]) {
	const tree: { indent: number, label: string }[] = []
	const stack: string[] = []
	for (const item of list) {
		const parts = item.split("/")
		let index = 0
		while (index < stack.length && stack[index] === parts[index]) {
			index++
		}
		stack.length = index
		while (index < parts.length) {
			stack.push(parts[index])
			tree.push({ indent: index + 1, label: parts[index] })
			index++
		}
	}
	return tree
}