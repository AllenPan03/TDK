define(["require", "exports", "/tdk/vendors/_tutils@2.1.2@tutils/path.js", "../builder.js", "../configs.js", "../shared/markdownList.js"], function (require, exports, path_1, builder_1, configs_1, markdownList_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findContainer = exports.generateIndex = exports.description = void 0;
    async function default_1(options) {
        try {
            const result = await generateIndex(options[1], !options["--no-update"], !options["--no-add"], options["--clean"] || options["-c"]);
            console.info(`目录“${path_1.relativePath(process.cwd(), result.data.path)}”更新完成(新增 ${result.added}${result.updated ? `, 更新 ${result.updated}` : ""}${result.removed ? `, 删除 ${result.removed}` : ""})`);
        }
        catch (e) {
            console.error(`目录更新失败：${e.stack}`);
        }
    }
    exports.default = default_1;
    exports.description = "自动生成索引";
    /**
     * 生成或更新索引文件夹
     * @param dir 根文件夹
     * @param update 是否重新从目录项读取标题
     * @param add 是否扫描并添加不存在的目录项
     * @param remove 是否删除不存在的目录项
     */
    async function generateIndex(dir, update, add, remove) {
        const builder = new builder_1.Builder(configs_1.readConfigs());
        const docCompiler = builder.docCompiler;
        const data = await docCompiler.loadPageIndex(dir !== null && dir !== void 0 ? dir : (dir = builder.options.srcDir));
        // 首次生成
        if (data.autoGenerated) {
            const newContent = `# ${path_1.getName(dir).toUpperCase()}\n${markdownList_1.formatMarkdownList(data.items)}`;
            await builder.fs.writeFile(data.path, newContent);
            return { builder, dir, data, created: true, added: count(data.items), updated: 0, removed: 0 };
            function count(list) {
                let result = 0;
                for (const item of list) {
                    if (item.children) {
                        result += count(item.children);
                    }
                    if (item.url !== undefined) {
                        result++;
                    }
                }
                return result;
            }
        }
        const result = { builder, dir, data, created: false, added: 0, updated: 0, removed: 0 };
        const existing = new Set();
        data.items = await updateItems(data.items);
        if (add) {
            await addMissingItems(await docCompiler.generatePageIndex(dir));
        }
        await builder.fs.writeFile(data.path, data.header + markdownList_1.formatMarkdownList(data.items) + data.body);
        return result;
        async function updateItems(items) {
            const newItems = [];
            for (const item of items) {
                if (item.children) {
                    item.children = await updateItems(item.children);
                }
                if (item.url === undefined) {
                    newItems.push(item);
                    continue;
                }
                existing.add(item.url);
                const path = path_1.resolvePath(dir, item.url);
                const itemInfo = await docCompiler.loadPageIndexItem(path, true);
                if (!itemInfo) {
                    if (remove) {
                        result.removed++;
                    }
                    else {
                        newItems.push(item);
                    }
                    continue;
                }
                if (update && (item.title !== itemInfo.title || item.subtitle !== itemInfo.subtitle)) {
                    result.updated++;
                    item.title = itemInfo.title;
                    item.subtitle = itemInfo.subtitle;
                }
                newItems.push(item);
            }
            return newItems;
        }
        async function addMissingItems(items) {
            for (const item of items) {
                if (item.children) {
                    await addMissingItems(item.children);
                }
                if (item.url === undefined || existing.has(item.url)) {
                    continue;
                }
                findContainer(data.items, item.url).push(item);
                result.added++;
            }
        }
    }
    exports.generateIndex = generateIndex;
    function findContainer(items, url) {
        const root = path_1.getRoot(url).toUpperCase();
        const item = items.find(item => item.children && item.title.toUpperCase() === root);
        if (item) {
            return findContainer(item.children, path_1.setRoot(url, ""));
        }
        return items;
    }
    exports.findContainer = findContainer;
});
//# sourceMappingURL=index.js.map